class color{
    constructor (r,g,b,a){
        this.r = r;
        this.g = g;
        this.b = b;
        if(a){
            this.a = a
        }else{
            this.a = 255
        }
    }

    static fromList(list){
        return new color(list[0],list[1],list[2])
    }

    most(){
        if(this.r > this.g && this.r >this.b){
            return 'r'
        }
        if(this.g >this.b){
            return 'g'
        }
        
        return 'b'
    }

    string(){
        if (this.a == 255){
            return `rgb(${this.r},${this.g},${this.b})`
        }
        return `rgba(${this.r},${this.g},${this.b}, ${this.a})`
    }
}

class ColorSpace{
    static fromUint8Array(uint8Array){
        let instance = new ColorSpace();
        instance.space = [];

        for (let i = 0; i < uint8Array.length - 4 ; i +=4){
            instance.space.push(new color(uint8Array[i], uint8Array[i + 1], uint8Array[i + 2]))
        }

        return instance
    }

    constructor(){
        this.space = [];
    }

    add(color){
        this.space.push(color)
    }

    sideLength(){
        let max = {r:0, g:0, b:0}
        let min = {r:255, g:255, b:255}

        this.space.map(function(color){
            // max color
            max.r = max.r < color.r ? color.r : max.r
            max.g = max.g < color.g ? color.g : max.g
            max.b = max.b < color.b ? color.b : max.b
            // min color
            min.r = min.r > color.r ? color.r : min.r
            min.g = min.g > color.g ? color.g : min.g
            min.b = min.b > color.b ? color.b : min.b
        })

        return new color(
            max.r - min.r,
            max.g - min.g,
            max.b - min.b
        )
    }

    split(side){
        // console.log(side) 
        let left = new ColorSpace()
        let right = new ColorSpace()

        let length = this.sideLength()[side]

        if(length == 1){ return [this]}

        let middle = ~~(length / 2) + this.zeropoint()[side]
        
        this.space.forEach(function(color){
            if(color[side] > middle){
                right.add(color)
            }else{
                left.add(color)
            }
        })
            
        return [left, right]
    }

    density(){
        let cube = this.sideLength();

        return cube.r * cube.g * cube.b * this.space.length();
    }

    longestSide(){
        return this.sideLength().most();
    }

    zeropoint(){
        let min = new color(255,255,255);

        this.space.map(function(color){
            min.r = min.r > color.r ? color.r : min.r
            min.g = min.g > color.g ? color.g : min.g
            min.b = min.b > color.b ? color.b : min.b
        })

        return min
    }

    midpoint(){
        let max = {r:0, g:0, b:0}
        let min = {r:255, g:255, b:255}

        this.space.map(function(color){
            // max color
            max.r = max.r < color.r ? color.r : max.r
            max.g = max.g < color.g ? color.g : max.g
            max.b = max.b < color.b ? color.b : max.b
            // min color
            min.r = min.r > color.r ? color.r : min.r
            min.g = min.g > color.g ? color.g : min.g
            min.b = min.b > color.b ? color.b : min.b
        })

        return new color(
            min.r + (max.r - min.r) / 2,
            min.g + (max.g - min.g) / 2,
            min.b + (max.b - min.b) / 2
        )
    }

}

class SteinsColor{
    static colors(url, block, callback){
        let instance = new SteinsColor;

        instance.getImageData(url, function(imgObj){
            let root = ColorSpace.fromUint8Array(imgObj.data)
            let cubeList = [root]
            
            let flag = 0

            // let result = root.split(root.longestSide())

            // console.log(result[0].midpoint(), result[1].midpoint())
            // console.log(result[0].zeropoint(), result[1].zeropoint())

            while(true){
                if (cubeList.length >= block){
                    break;
                }
                
                let cube = cubeList.splice(0,1).pop();
                if (cube == undefined) { break; }

                if (flag != 0 && flag.space.length == cube.space.length){
                    break;
                }

                flag = cube
                
                let result = cube.split(cube.longestSide())

                result.forEach(function(s){
                    if(s.space.length != 0){
                        cubeList.push(s)
                    }
                })
                // cubeList = cubeList.concat(...cube.split(cube.longestSide()))
            }

            for(let i = 0; i < cubeList.length; i++){ 
                cubeList[i] = cubeList[i].midpoint()
            }

            callback(cubeList)
        })
    }

    open (url, callback) {
        let img = new Image();
    
        img.onload = function() {
            callback(img);
        }
        img.crossOrigin = "Anonymous"
        img.src = url
    }
    
    imgData (img, callback) {
        let canvas = document.createElement('canvas')
        canvas.width = img.width
        canvas.height = img.height
        let context = canvas.getContext('2d')
    
        context.drawImage(img, 0, 0)
    
        var data = context.getImageData(0,0,img.width,img.height)
    
        callback(data)
    }
    
    getImageData(url, callback) {
        let that = this
        this.open(url, function(imgObj){
            that.imgData(imgObj, callback)
        })
    }
}